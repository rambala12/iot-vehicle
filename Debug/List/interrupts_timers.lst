###############################################################################
#
# IAR C/C++ Compiler V7.12.1.987/W32 for MSP430           23/Apr/2019  18:40:13
# Copyright 1996-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 7.12
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        \\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\interrupts_timers.c
#    Command line  =  
#        -f C:\Users\rambala\AppData\Local\Temp\EWB1D5.tmp
#        ("\\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\interrupts_timers.c" -lC
#        "\\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\Debug\List" -o
#        "\\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\Debug\Obj" --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --debug -D__MSP430FR2355__ -e --double=32 --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\430\lib\dlib\dl430xlsfn.h" -I ./\ --core=430X --data_model=small
#        -On --multiplier=32 --hw_workaround=CPU40 --code_model=large)
#    Locale        =  English_USA.1252
#    List file     =  
#        \\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\Debug\List\interrupts_timers.lst
#    Object file   =  
#        \\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project
#        10\Debug\Obj\interrupts_timers.r43
#
###############################################################################

\\Mac\Home\Desktop\ECE306\autonomous-iot-vehicle\Projects\Project 10\interrupts_timers.c
      1          //------------------------------------------------------------------------------
      2          //
      3          //  Description: This file contains the timer interrupts
      4          //
      5          //
      6          //  Ram Bala
      7          //  Feb 2019
      8          //  Built with IAR Embedded Workbench Version: V4.10A/W32 (7.11.2)
      9          //------------------------------------------------------------------------------
     10          
     11          #include "macros.h"
     12          #include "functions.h"
     13          #include  "msp430.h"

   \                                 In  segment DATA16_AN, at 0x21a
   \   union <unnamed> _A_PAIE_L
   \                     _A_PAIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21c
   \   union <unnamed> _A_PAIFG_L
   \                     _A_PAIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23a
   \   union <unnamed> _A_PBIE_L
   \                     _A_PBIE_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x23c
   \   union <unnamed> _A_PBIFG_L
   \                     _A_PBIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x384
   \   union <unnamed> _A_TB0CCTL1_L
   \                     _A_TB0CCTL1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x386
   \   union <unnamed> _A_TB0CCTL2_L
   \                     _A_TB0CCTL2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x392
   \   union <unnamed> _A_TB0CCR0_L
   \                     _A_TB0CCR0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x394
   \   union <unnamed> _A_TB0CCR1_L
   \                     _A_TB0CCR1_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x396
   \   union <unnamed> _A_TB0CCR2_L
   \                     _A_TB0CCR2_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3ae
   \   union <unnamed> _A_TB0IV_L
   \                     _A_TB0IV_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x3d2
   \   union <unnamed> _A_TB1CCR0_L
   \                     _A_TB1CCR0_L:
   \   000000                DS8 2
     14          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     15          unsigned int blink_count = ZERO;
   \                     blink_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          unsigned int display_count = ZERO;
   \                     display_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          unsigned int ping_count = ZERO;
   \                     ping_count:
   \   000000                DS8 2
     18          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          extern int move_count = ZERO;
   \                     move_count:
   \   000000                DS8 2
     20          extern int serial_count;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          unsigned int move_timer = ZERO;
   \                     move_timer:
   \   000000                DS8 2
     22          extern volatile unsigned char update_display;
     23          extern volatile unsigned int Time_Sequence;
     24          extern volatile char one_time;

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25          unsigned int debounce_count = ZERO;
   \                     debounce_count:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     26          extern volatile int pause_activated = ZERO;
   \                     pause_activated:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     27          extern volatile int START_IOT = ZERO;
   \                     START_IOT:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28          unsigned int iot_timer = ZERO;
   \                     iot_timer:
   \   000000                DS8 2
     29          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     30          unsigned int init_timer = ZERO;
   \                     init_timer:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     31          unsigned int init_count = ZERO;
   \                     init_count:
   \   000000                DS8 2
     32          
     33          // globals for setting movement timer based on command

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     34          extern volatile int command_activated = ZERO;
   \                     command_activated:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     35          unsigned int run_timer = ZERO;
   \                     run_timer:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     36          extern volatile int run_count = ZERO;
   \                     run_count:
   \   000000                DS8 2
     37          extern volatile int initialize;
     38          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     39          extern volatile int circle_activated = ZERO;
   \                     circle_activated:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     40          unsigned int circle_timer = ZERO;
   \                     circle_timer:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     41          extern volatile int circle_count = ZERO;
   \                     circle_count:
   \   000000                DS8 2
     42          extern int disp_iot;
     43          
     44          
     45          #pragma vector = TIMER0_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     46          __interrupt void Timer0_B0_ISR(void) {
   \                     Timer0_B0_ISR:
   \   000000   3F15         PUSHM.W #0x4, R15
     47          	//--------------------------------------------------------------------
     48          	// TimerB0 0 Interrupt handler
     49          	//--------------------------------------------------------------------
     50          	// LCD Backlight
     51          	// if(blink_count++ > FIFTY_MS_COUNT){
     52          	// 	blink_count = ZERO; // Reset for next count
     53          	//  	P6OUT ^= LCD_BACKLITE; // Flip State of LCD_BACKLITE
     54          	// }
     55          	if(display_count++ > DISPLAY_UPDATE) {
   \   000002   1F42....     MOV.W   &display_count, R15
   \   000006   0E4F         MOV.W   R15, R14
   \   000008   1E53         ADD.W   #0x1, R14
   \   00000A   824E....     MOV.W   R14, &display_count
   \   00000E   2F92         CMP.W   #0x4, R15
   \   000010   0428         JNC     ??Timer0_B0_ISR_0
     56          		display_count = ZERO;
   \   000012   8243....     MOV.W   #0x0, &display_count
     57          		update_display = ONE;
   \   000016   D243....     MOV.B   #0x1, &update_display
     58          	}
     59          	if (disp_iot) {
   \                     ??Timer0_B0_ISR_0:
   \   00001A   8293....     CMP.W   #0x0, &disp_iot
   \   00001E   1024         JEQ     ??Timer0_B0_ISR_1
     60          		if (ping_count++ > DISPLAY_UPDATE) {
   \   000020   1F42....     MOV.W   &ping_count, R15
   \   000024   0E4F         MOV.W   R15, R14
   \   000026   1E53         ADD.W   #0x1, R14
   \   000028   824E....     MOV.W   R14, &ping_count
   \   00002C   2F92         CMP.W   #0x4, R15
   \   00002E   0828         JNC     ??Timer0_B0_ISR_1
     61          			ping_count = ZERO;
   \   000030   8243....     MOV.W   #0x0, &ping_count
     62          			move_count += INDEX_TWO; // if count increases, .2 second has passed
   \   000034   A253....     ADD.W   #0x2, &move_count
     63          			sendToIOT("AT+Ping=google.com,1\r\n");
   \   000038   3C40....     MOV.W   #`?<Constant "AT+Ping=google.com,1\\r\\n">`, R12
   \   00003C   ........     CALLA   #sendToIOT
     64          		}
     65          	}
     66          	// Time Sequence
     67          	 one_time = ONE;
   \                     ??Timer0_B0_ISR_1:
   \   000040   D243....     MOV.B   #0x1, &one_time
     68          	 if(Time_Sequence++ > CASE1){
   \   000044   1F42....     MOV.W   &Time_Sequence, R15
   \   000048   0E4F         MOV.W   R15, R14
   \   00004A   1E53         ADD.W   #0x1, R14
   \   00004C   824E....     MOV.W   R14, &Time_Sequence
   \   000050   3F90FB00     CMP.W   #0xfb, R15
   \   000054   0228         JNC     ??Timer0_B0_ISR_2
     69          	 	Time_Sequence = ZERO;
   \   000056   8243....     MOV.W   #0x0, &Time_Sequence
     70          	 }
     71          	 TB0CCR0 += TB0CCR0_INTERVAL; // Add interval Offset to TACCR0
   \                     ??Timer0_B0_ISR_2:
   \   00005A   B250A8619203 ADD.W   #0x61a8, &0x392
     72          }
   \   000060   3C17         POPM.W  #0x4, R15
   \   000062   0013         RETI
   \   000064                REQUIRE _A_TB0CCR0_L
     73          
     74          #pragma vector = TIMER0_B1_VECTOR

   \                                 In  segment ISR_CODE, align 2
     75          __interrupt void Timer0_B1_ISR(void) {
   \                     Timer0_B1_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
     76          	switch(__even_in_range(TB0IV, TIMER_INTER_FOURTEEN)) {
   \   000002   1F42AE03     MOV.W   &0x3ae, R15
   \   000006   E00F         ADDA    R15, PC
   \                     `?<Jumptable for Timer0_B1_ISR>_0`:
   \   000008   323C         JMP     ??Timer0_B1_ISR_1
   \   00000A   063C         JMP     ??Timer0_B1_ISR_4
   \   00000C   1B3C         JMP     ??Timer0_B1_ISR_5
   \   00000E   2F3C         JMP     ??Timer0_B1_ISR_1
   \   000010   2E3C         JMP     ??Timer0_B1_ISR_1
   \   000012   2D3C         JMP     ??Timer0_B1_ISR_1
   \   000014   2C3C         JMP     ??Timer0_B1_ISR_1
   \   000016   2B3C         JMP     ??Timer0_B1_ISR_1
     77          		case ZERO: break;
     78          		case TIMER_INTER_TWO:
     79          			// Timer debounce interrupt for switch 1
     80          			if (debounce_count++ > DEBOUNCE_TIME) {
   \                     ??Timer0_B1_ISR_4:
   \   000018   1F42....     MOV.W   &debounce_count, R15
   \   00001C   0E4F         MOV.W   R15, R14
   \   00001E   1E53         ADD.W   #0x1, R14
   \   000020   824E....     MOV.W   R14, &debounce_count
   \   000024   3F901000     CMP.W   #0x10, R15
   \   000028   0928         JNC     ??Timer0_B1_ISR_2
     81          				debounce_count = ZERO;
   \   00002A   8243....     MOV.W   #0x0, &debounce_count
     82          				P4IE |= SW1;
   \   00002E   E2D33B02     BIS.B   #0x2, &0x23b
     83          				TB0CCTL1 &= ~CCIE;
   \   000032   B2C010008403 BIC.W   #0x10, &0x384
     84          				P4IFG &= ~SW1;
   \   000038   E2C33D02     BIC.B   #0x2, &0x23d
     85          			}
     86          			TB0CCR1 += TB0CCR1_INTERVAL;
   \                     ??Timer0_B1_ISR_2:
   \   00003C   B250A8619403 ADD.W   #0x61a8, &0x394
     87          			break;
   \   000042   153C         JMP     ??Timer0_B1_ISR_1
     88          		case TIMER_INTER_FOUR:
     89          			if (debounce_count++ > DEBOUNCE_TIME) {
   \                     ??Timer0_B1_ISR_5:
   \   000044   1F42....     MOV.W   &debounce_count, R15
   \   000048   0E4F         MOV.W   R15, R14
   \   00004A   1E53         ADD.W   #0x1, R14
   \   00004C   824E....     MOV.W   R14, &debounce_count
   \   000050   3F901000     CMP.W   #0x10, R15
   \   000054   0928         JNC     ??Timer0_B1_ISR_3
     90          				debounce_count = ZERO;
   \   000056   8243....     MOV.W   #0x0, &debounce_count
     91          				P2IE |= SW2;
   \   00005A   F2D21B02     BIS.B   #0x8, &0x21b
     92          				TB0CCTL2 &= ~CCIE;
   \   00005E   B2C010008603 BIC.W   #0x10, &0x386
     93          				P2IFG &= ~SW2;
   \   000064   F2C21D02     BIC.B   #0x8, &0x21d
     94          			}
     95          			TB0CCR2 += TB0CCR2_INTERVAL;
   \                     ??Timer0_B1_ISR_3:
   \   000068   B250A8619603 ADD.W   #0x61a8, &0x396
     96          			break;
     97          		case TIMER_INTER_FOURTEEN:
     98          			break;
     99          		default: break;
    100          	}
    101          }
   \                     ??Timer0_B1_ISR_1:
   \   00006E   1E17         POPM.W  #0x2, R15
   \   000070   0013         RETI
   \   000072                REQUIRE _A_PBIE_L
   \   000072                REQUIRE _A_TB0CCTL1_L
   \   000072                REQUIRE _A_PBIFG_L
   \   000072                REQUIRE _A_TB0CCR1_L
   \   000072                REQUIRE _A_PAIE_L
   \   000072                REQUIRE _A_TB0CCTL2_L
   \   000072                REQUIRE _A_PAIFG_L
   \   000072                REQUIRE _A_TB0CCR2_L
   \   000072                REQUIRE _A_TB0IV_L
    102          
    103          #pragma vector = TIMER1_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
    104          __interrupt void Timer1_B0_ISR(void) {
   \                     Timer1_B0_ISR:
   \   000000   1F15         PUSHM.W #0x2, R15
    105          	if (pause_activated) {
   \   000002   8293....     CMP.W   #0x0, &pause_activated
   \   000006   0F24         JEQ     ??Timer1_B0_ISR_0
    106          		if(move_timer++ > ONE_SEC_COUNT){
   \   000008   1F42....     MOV.W   &move_timer, R15
   \   00000C   0E4F         MOV.W   R15, R14
   \   00000E   1E53         ADD.W   #0x1, R14
   \   000010   824E....     MOV.W   R14, &move_timer
   \   000014   3F901500     CMP.W   #0x15, R15
   \   000018   0428         JNC     ??Timer1_B0_ISR_1
    107          			move_timer = ZERO; // Reset for next count
   \   00001A   8243....     MOV.W   #0x0, &move_timer
    108          			serial_count++; // if count increases, 1 second has passed
   \   00001E   9253....     ADD.W   #0x1, &serial_count
    109          		}
    110          		pause_activated = ZERO;
   \                     ??Timer1_B0_ISR_1:
   \   000022   8243....     MOV.W   #0x0, &pause_activated
    111          	}
    112          
    113          	if (init_timer++ > HUNDRED_MS_COUNT) {
   \                     ??Timer1_B0_ISR_0:
   \   000026   1F42....     MOV.W   &init_timer, R15
   \   00002A   0E4F         MOV.W   R15, R14
   \   00002C   1E53         ADD.W   #0x1, R14
   \   00002E   824E....     MOV.W   R14, &init_timer
   \   000032   3F900300     CMP.W   #0x3, R15
   \   000036   0A28         JNC     ??Timer1_B0_ISR_2
    114          		init_timer = ZERO;
   \   000038   8243....     MOV.W   #0x0, &init_timer
    115          		init_count++;
   \   00003C   9253....     ADD.W   #0x1, &init_count
    116          		// if some time has passed, activate initialization
    117          		if (init_count == SETUP_TIME) initialize = INDEX_ONE;
   \   000040   B2901900.... CMP.W   #0x19, &init_count
   \   000046   0220         JNE     ??Timer1_B0_ISR_2
   \   000048   9243....     MOV.W   #0x1, &initialize
    118          	}
    119          
    120          	// timer for starting iot module initially
    121          	if (iot_timer++ > HUNDRED_MS_COUNT) {
   \                     ??Timer1_B0_ISR_2:
   \   00004C   1F42....     MOV.W   &iot_timer, R15
   \   000050   0E4F         MOV.W   R15, R14
   \   000052   1E53         ADD.W   #0x1, R14
   \   000054   824E....     MOV.W   R14, &iot_timer
   \   000058   3F900300     CMP.W   #0x3, R15
   \   00005C   0428         JNC     ??Timer1_B0_ISR_3
    122          		iot_timer = ZERO;
   \   00005E   8243....     MOV.W   #0x0, &iot_timer
    123          		START_IOT = INDEX_ONE;
   \   000062   9243....     MOV.W   #0x1, &START_IOT
    124          	}
    125          
    126          	// if the command is ready to go, then the timer will activate for
    127          	// allowing command to happen for that many seconds : use ms timer
    128          	if (command_activated) {
   \                     ??Timer1_B0_ISR_3:
   \   000066   8293....     CMP.W   #0x0, &command_activated
   \   00006A   0D24         JEQ     ??Timer1_B0_ISR_4
    129          		if (run_timer++ > DISPLAY_UPDATE) {
   \   00006C   1F42....     MOV.W   &run_timer, R15
   \   000070   0E4F         MOV.W   R15, R14
   \   000072   1E53         ADD.W   #0x1, R14
   \   000074   824E....     MOV.W   R14, &run_timer
   \   000078   2F92         CMP.W   #0x4, R15
   \   00007A   0528         JNC     ??Timer1_B0_ISR_4
    130          			run_timer = ZERO;
   \   00007C   8243....     MOV.W   #0x0, &run_timer
    131          			run_count+= INDEX_TEN; // if run_count increases, .2 seconds has passed
   \   000080   B2500A00.... ADD.W   #0xa, &run_count
    132          		}
    133          		//command_activated = ZERO;
    134          	}
    135          	// once command is done: RESET run_count back to 0
    136          
    137          	// if (circle_activated) {
    138          	// 	if (circle_timer++ > DISPLAY_UPDATE) {
    139          	// 		circle_timer = ZERO;
    140          	// 		circle_count+= INDEX_TWO; // if run_count increases, .2 seconds has passed
    141          	// 	}
    142          	// }
    143          
    144          
    145          	TB1CCR0 += TB1CCR0_INTERVAL;
   \                     ??Timer1_B0_ISR_4:
   \   000086   B250A861D203 ADD.W   #0x61a8, &0x3d2
    146          }
   \   00008C   1E17         POPM.W  #0x2, R15
   \   00008E   0013         RETI
   \   000090                REQUIRE _A_TB1CCR0_L

   \                                 In  segment INTVEC, offset 0x52, root
   \                     `??Timer1_B0_ISR::??INTVEC 82`:
   \   000052   ....         DC16    Timer1_B0_ISR

   \                                 In  segment INTVEC, offset 0x54, root
   \                     `??Timer0_B1_ISR::??INTVEC 84`:
   \   000054   ....         DC16    Timer0_B1_ISR

   \                                 In  segment INTVEC, offset 0x56, root
   \                     `??Timer0_B0_ISR::??INTVEC 86`:
   \   000056   ....         DC16    Timer0_B0_ISR

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "AT+Ping=google.com,1\\r\\n">`:
   \   000000   41542B50696E DC8 "AT+Ping=google.com,1\015\012"
   \            673D676F6F67
   \            6C652E636F6D
   \            2C310D0A00  
    147          
    148          
    149          
    150          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   Timer0_B0_ISR
       12   -> sendToIOT
      8   Timer0_B1_ISR
      8   Timer1_B0_ISR


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      23  ?<Constant "AT+Ping=google.com,1\r\n">
       2  START_IOT
     100  Timer0_B0_ISR
       2  Timer0_B0_ISR::??INTVEC 86
     114  Timer0_B1_ISR
       2  Timer0_B1_ISR::??INTVEC 84
     144  Timer1_B0_ISR
       2  Timer1_B0_ISR::??INTVEC 82
       2  _A_PAIE_L
       2  _A_PAIFG_L
       2  _A_PBIE_L
       2  _A_PBIFG_L
       2  _A_TB0CCR0_L
       2  _A_TB0CCR1_L
       2  _A_TB0CCR2_L
       2  _A_TB0CCTL1_L
       2  _A_TB0CCTL2_L
       2  _A_TB0IV_L
       2  _A_TB1CCR0_L
       2  blink_count
       2  circle_activated
       2  circle_count
       2  circle_timer
       2  command_activated
       2  debounce_count
       2  display_count
       2  init_count
       2  init_timer
       2  iot_timer
       2  move_count
       2  move_timer
       2  pause_activated
       2  ping_count
       2  run_count
       2  run_timer

 
  22 bytes in segment DATA16_AN
  23 bytes in segment DATA16_C
  34 bytes in segment DATA16_Z
   6 bytes in segment INTVEC
 358 bytes in segment ISR_CODE
 
 358 bytes of CODE  memory
  23 bytes of CONST memory (+  6 bytes shared)
  34 bytes of DATA  memory (+ 22 bytes shared)

Errors: none
Warnings: none
